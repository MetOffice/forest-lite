{"version":3,"artifacts":[{"module":{"file":"/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib/index.js","base":"/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib","base_path":"index.js","canonical":"index","resolution":"ESM","id":"e1b43c024c","hash":"e1b43c024ccc9c531678aa346347b1a58b4715d3ff50af3fb0486b7c98ce0b08","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar image_timestamp_1 = require(\"./image_timestamp\");\nexports.ImageTimestamp = image_timestamp_1.ImageTimestamp;\n//# sourceMappingURL=index.js.map\n","type":"js","dependency_paths":[["./image_timestamp","/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib/image_timestamp.js"]],"dependency_map":[],"externals":[],"shims":[]},"code":{"source":"/* index.js */ function _(require, module, exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var image_timestamp_1 = require(\"4f96ca39c4\") /* ./image_timestamp */;\n    exports.ImageTimestamp = image_timestamp_1.ImageTimestamp;\n}\n","min_source":"function _(e,a,m){Object.defineProperty(m,\"__esModule\",{value:!0});var t=e(\"4f96ca39c4\");m.ImageTimestamp=t.ImageTimestamp}\n//# sourceMappingURL=index.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"image_timestamp_1\",\"ImageTimestamp\"],\"mappings\":\"AAAe,SAASA,EAAEC,EAASC,EAAQC,GACvCC,OAAOC,eAAeF,EAAS,aAAc,CAAEG,OAAO,IACtD,IAAIC,EAAoBN,EAAQ,cAChCE,EAAQK,eAAiBD,EAAkBC\",\"file\":\"index.min.js\"}"}},{"module":{"file":"/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib/image_timestamp.js","base":"/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib","base_path":"image_timestamp.js","canonical":"image_timestamp","resolution":"ESM","id":"4f96ca39c4","hash":"4f96ca39c481b7495df7d33d74179cbce42d03bfdddfb1b2f45d563ffd9881fa","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst image_timestamp_base_1 = require(\"./image_timestamp_base\");\nconst color_mapper_1 = require(\"@bokehjs/models/mappers/color_mapper\");\nconst linear_color_mapper_1 = require(\"@bokehjs/models/mappers/linear_color_mapper\");\nclass ImageView extends image_timestamp_base_1.ImageTimestampBaseView {\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.color_mapper.change, () => this._update_image());\n    }\n    initialize() {\n        super.initialize();\n        // Game loop ?\n        window.requestAnimationFrame(this._frame);\n    }\n    _frame(timeStamp) {\n        console.log(timeStamp);\n    }\n    _update_image() {\n        // Only reset image_data if already initialized\n        if (this.image_data != null) {\n            this._set_data(null);\n            this.renderer.plot_view.request_render();\n        }\n    }\n    _flat_img_to_buf8(img) {\n        const cmap = this.model.color_mapper.rgba_mapper;\n        return cmap.v_compute(img);\n    }\n}\nexports.ImageView = ImageView;\nImageView.__name__ = \"ImageView\";\n// NOTE: this needs to be redefined here, because palettes are located in bokeh-api.js bundle\nconst Greys9 = () => [\"#000000\", \"#252525\", \"#525252\", \"#737373\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\", \"#f0f0f0\", \"#ffffff\"];\nclass ImageTimestamp extends image_timestamp_base_1.ImageTimestampBase {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_ImageTimestamp() {\n        this.prototype.default_view = ImageView;\n        this.define(({ Ref }) => ({\n            color_mapper: [Ref(color_mapper_1.ColorMapper), () => new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() })],\n        }));\n    }\n}\nexports.ImageTimestamp = ImageTimestamp;\nImageTimestamp.__name__ = \"ImageTimestamp\";\nImageTimestamp.init_ImageTimestamp();\n//# sourceMappingURL=image_timestamp.js.map\n","type":"js","dependency_paths":[["./image_timestamp_base","/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib/image_timestamp_base.js"]],"dependency_map":[],"externals":[],"shims":[]},"code":{"source":"/* image_timestamp.js */ function _(require, module, exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const image_timestamp_base_1 = require(\"f9514df777\") /* ./image_timestamp_base */;\n    const color_mapper_1 = require(\"@bokehjs/models/mappers/color_mapper\");\n    const linear_color_mapper_1 = require(\"@bokehjs/models/mappers/linear_color_mapper\");\n    class ImageView extends image_timestamp_base_1.ImageTimestampBaseView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.color_mapper.change, () => this._update_image());\n        }\n        initialize() {\n            super.initialize();\n            // Game loop ?\n            window.requestAnimationFrame(this._frame);\n        }\n        _frame(timeStamp) {\n            console.log(timeStamp);\n        }\n        _update_image() {\n            // Only reset image_data if already initialized\n            if (this.image_data != null) {\n                this._set_data(null);\n                this.renderer.plot_view.request_render();\n            }\n        }\n        _flat_img_to_buf8(img) {\n            const cmap = this.model.color_mapper.rgba_mapper;\n            return cmap.v_compute(img);\n        }\n    }\n    exports.ImageView = ImageView;\n    ImageView.__name__ = \"ImageView\";\n    // NOTE: this needs to be redefined here, because palettes are located in bokeh-api.js bundle\n    const Greys9 = () => [\"#000000\", \"#252525\", \"#525252\", \"#737373\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\", \"#f0f0f0\", \"#ffffff\"];\n    class ImageTimestamp extends image_timestamp_base_1.ImageTimestampBase {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageTimestamp() {\n            this.prototype.default_view = ImageView;\n            this.define(({ Ref }) => ({\n                color_mapper: [Ref(color_mapper_1.ColorMapper), () => new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() })],\n            }));\n        }\n    }\n    exports.ImageTimestamp = ImageTimestamp;\n    ImageTimestamp.__name__ = \"ImageTimestamp\";\n    ImageTimestamp.init_ImageTimestamp();\n}\n","min_source":"function _(e,a,t){Object.defineProperty(t,\"__esModule\",{value:!0});const i=e(\"f9514df777\"),s=e(\"@bokehjs/models/mappers/color_mapper\"),m=e(\"@bokehjs/models/mappers/linear_color_mapper\");class r extends i.ImageTimestampBaseView{connect_signals(){super.connect_signals(),this.connect(this.model.color_mapper.change,()=>this._update_image())}initialize(){super.initialize(),window.requestAnimationFrame(this._frame)}_frame(e){console.log(e)}_update_image(){null!=this.image_data&&(this._set_data(null),this.renderer.plot_view.request_render())}_flat_img_to_buf8(e){return this.model.color_mapper.rgba_mapper.v_compute(e)}}t.ImageView=r,r.__name__=\"ImageView\";class o extends i.ImageTimestampBase{constructor(e){super(e)}static init_ImageTimestamp(){this.prototype.default_view=r,this.define(({Ref:e})=>({color_mapper:[e(s.ColorMapper),()=>new m.LinearColorMapper({palette:[\"#000000\",\"#252525\",\"#525252\",\"#737373\",\"#969696\",\"#bdbdbd\",\"#d9d9d9\",\"#f0f0f0\",\"#ffffff\"]})]}))}}t.ImageTimestamp=o,o.__name__=\"ImageTimestamp\",o.init_ImageTimestamp()}\n//# sourceMappingURL=image_timestamp.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"image_timestamp_base_1\",\"color_mapper_1\",\"linear_color_mapper_1\",\"ImageView\",\"ImageTimestampBaseView\",\"[object Object]\",\"super\",\"connect_signals\",\"this\",\"connect\",\"model\",\"color_mapper\",\"change\",\"_update_image\",\"initialize\",\"window\",\"requestAnimationFrame\",\"_frame\",\"timeStamp\",\"console\",\"log\",\"image_data\",\"_set_data\",\"renderer\",\"plot_view\",\"request_render\",\"img\",\"rgba_mapper\",\"v_compute\",\"__name__\",\"ImageTimestamp\",\"ImageTimestampBase\",\"attrs\",\"prototype\",\"default_view\",\"define\",\"Ref\",\"ColorMapper\",\"LinearColorMapper\",\"palette\",\"init_ImageTimestamp\"],\"mappings\":\"AAAyB,SAASA,EAAEC,EAASC,EAAQC,GACjDC,OAAOC,eAAeF,EAAS,aAAc,CAAEG,OAAO,IACtD,MAAMC,EAAyBN,EAAQ,cACjCO,EAAiBP,EAAQ,wCACzBQ,EAAwBR,EAAQ,+CACtC,MAAMS,UAAkBH,EAAuBI,uBAC3CC,kBACIC,MAAMC,kBACNC,KAAKC,QAAQD,KAAKE,MAAMC,aAAaC,OAAQ,IAAMJ,KAAKK,iBAE5DR,aACIC,MAAMQ,aAENC,OAAOC,sBAAsBR,KAAKS,QAEtCZ,OAAOa,GACHC,QAAQC,IAAIF,GAEhBb,gBAE2B,MAAnBG,KAAKa,aACLb,KAAKc,UAAU,MACfd,KAAKe,SAASC,UAAUC,kBAGhCpB,kBAAkBqB,GAEd,OADalB,KAAKE,MAAMC,aAAagB,YACzBC,UAAUF,IAG9B9B,EAAQO,UAAYA,EACpBA,EAAU0B,SAAW,YAGrB,MAAMC,UAAuB9B,EAAuB+B,mBAChD1B,YAAY2B,GACR1B,MAAM0B,GAEV3B,6BACIG,KAAKyB,UAAUC,aAAe/B,EAC9BK,KAAK2B,OAAO,EAAGC,IAAAA,MAAU,CACrBzB,aAAc,CAACyB,EAAInC,EAAeoC,aAAc,IAAM,IAAInC,EAAsBoC,kBAAkB,CAAEC,QAR3F,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,kBAY9G3C,EAAQkC,eAAiBA,EACzBA,EAAeD,SAAW,iBAC1BC,EAAeU\",\"file\":\"image_timestamp.min.js\"}"}},{"module":{"file":"/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib/image_timestamp_base.js","base":"/net/home/h03/frrn/software/github/forest-lite/forest_lite/client/extension/dist/lib","base_path":"image_timestamp_base.js","canonical":"image_timestamp_base","resolution":"ESM","id":"f9514df777","hash":"f9514df777bf52e37160e14364781250a01d94459a4ecb6d3f90aa02c326bc3e","source":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst xy_glyph_1 = require(\"@bokehjs/models/glyphs/xy_glyph\");\nconst types_1 = require(\"@bokehjs/core/types\");\nconst p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\nconst selection_1 = require(\"@bokehjs/models/selections/selection\");\nconst array_1 = require(\"@bokehjs/core/util/array\");\nconst ndarray_1 = require(\"@bokehjs/core/util/ndarray\");\nconst assert_1 = require(\"@bokehjs/core/util/assert\");\nclass ImageTimestampBaseView extends xy_glyph_1.XYGlyphView {\n    constructor(options) {\n        super(options);\n    }\n    connect_signals() {\n        super.connect_signals();\n        this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n        this.connect(this.model.properties.time_stamp.change, () => {\n            // this.renderer.set_data()\n            this.renderer.request_render();\n        });\n    }\n    _render(ctx, indices, { image_data, sx, sy, sw, sh }) {\n        const old_smoothing = ctx.getImageSmoothingEnabled();\n        ctx.setImageSmoothingEnabled(false);\n        ctx.globalAlpha = this.model.global_alpha;\n        for (const i of indices) {\n            if (image_data[i] == null || isNaN(sx[i] + sy[i] + sw[i] + sh[i]))\n                continue;\n            const y_offset = sy[i];\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n            ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n            ctx.translate(0, y_offset);\n            ctx.scale(1, -1);\n            ctx.translate(0, -y_offset);\n        }\n        ctx.setImageSmoothingEnabled(old_smoothing);\n    }\n    _set_data(indices) {\n        console.log(\"_set_data\");\n        this._set_width_heigh_data();\n        for (let i = 0, end = this._image.length; i < end; i++) {\n            if (indices != null && indices.indexOf(i) < 0)\n                continue;\n            const img = this._image[i](this.model.time_stamp);\n            let flat_img;\n            if (ndarray_1.is_NDArray(img)) {\n                assert_1.assert(img.dimension == 2, \"expected a 2D array\");\n                flat_img = img;\n                this._height[i] = img.shape[0];\n                this._width[i] = img.shape[1];\n            }\n            else {\n                flat_img = array_1.concat(img);\n                this._height[i] = img.length;\n                this._width[i] = img[0].length;\n            }\n            const buf8 = this._flat_img_to_buf8(flat_img);\n            this._set_image_data_from_buffer(i, buf8);\n        }\n    }\n    _index_data(index) {\n        const { data_size } = this;\n        for (let i = 0; i < data_size; i++) {\n            const [l, r, t, b] = this._lrtb(i);\n            if (isNaN(l + r + t + b) || !isFinite(l + r + t + b))\n                index.add_empty();\n            else\n                index.add(l, b, r, t);\n        }\n    }\n    _lrtb(i) {\n        const xr = this.renderer.xscale.source_range;\n        const x1 = this._x[i];\n        const x2 = xr.is_reversed ? x1 - this._dw[i] : x1 + this._dw[i];\n        const yr = this.renderer.yscale.source_range;\n        const y1 = this._y[i];\n        const y2 = yr.is_reversed ? y1 - this._dh[i] : y1 + this._dh[i];\n        const [l, r] = x1 < x2 ? [x1, x2] : [x2, x1];\n        const [b, t] = y1 < y2 ? [y1, y2] : [y2, y1];\n        return [l, r, t, b];\n    }\n    _set_width_heigh_data() {\n        if (this.image_data == null || this.image_data.length != this._image.length)\n            this.image_data = new Array(this._image.length);\n        if (this._width == null || this._width.length != this._image.length)\n            this._width = new types_1.NumberArray(this._image.length);\n        if (this._height == null || this._height.length != this._image.length)\n            this._height = new types_1.NumberArray(this._image.length);\n    }\n    _get_or_create_canvas(i) {\n        const _image_data = this.image_data[i];\n        if (_image_data != null && _image_data.width == this._width[i] &&\n            _image_data.height == this._height[i])\n            return _image_data;\n        else {\n            const canvas = document.createElement('canvas');\n            canvas.width = this._width[i];\n            canvas.height = this._height[i];\n            return canvas;\n        }\n    }\n    _set_image_data_from_buffer(i, buf8) {\n        const canvas = this._get_or_create_canvas(i);\n        const ctx = canvas.getContext('2d');\n        const image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n        image_data.data.set(buf8);\n        ctx.putImageData(image_data, 0, 0);\n        this.image_data[i] = canvas;\n    }\n    _map_data() {\n        switch (this.model.properties.dw.units) {\n            case \"data\": {\n                this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\n                break;\n            }\n            case \"screen\": {\n                this.sw = this._dw;\n                break;\n            }\n        }\n        switch (this.model.properties.dh.units) {\n            case \"data\": {\n                this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\n                break;\n            }\n            case \"screen\": {\n                this.sh = this._dh;\n                break;\n            }\n        }\n    }\n    _image_index(index, x, y) {\n        const [l, r, t, b] = this._lrtb(index);\n        const width = this._width[index];\n        const height = this._height[index];\n        const dx = (r - l) / width;\n        const dy = (t - b) / height;\n        let dim1 = Math.floor((x - l) / dx);\n        let dim2 = Math.floor((y - b) / dy);\n        if (this.renderer.xscale.source_range.is_reversed)\n            dim1 = width - dim1 - 1;\n        if (this.renderer.yscale.source_range.is_reversed)\n            dim2 = height - dim2 - 1;\n        return { index, dim1, dim2, flat_index: dim2 * width + dim1 };\n    }\n    _hit_point(geometry) {\n        const { sx, sy } = geometry;\n        const x = this.renderer.xscale.invert(sx);\n        const y = this.renderer.yscale.invert(sy);\n        const candidates = this.index.indices({ x0: x, x1: x, y0: y, y1: y });\n        const result = new selection_1.Selection();\n        for (const index of candidates) {\n            if (sx != Infinity && sy != Infinity) {\n                result.image_indices.push(this._image_index(index, x, y));\n            }\n        }\n        return result;\n    }\n}\nexports.ImageTimestampBaseView = ImageTimestampBaseView;\nImageTimestampBaseView.__name__ = \"ImageTimestampBaseView\";\nclass ImageTimestampBase extends xy_glyph_1.XYGlyph {\n    constructor(attrs) {\n        super(attrs);\n    }\n    static init_ImageTimestampBase() {\n        this.define({\n            image: [p.NDArraySpec],\n            dw: [p.DistanceSpec],\n            dh: [p.DistanceSpec],\n            dilate: [p.Boolean, false],\n            global_alpha: [p.Number, 1.0],\n            time_stamp: [p.Number, 1.0],\n        });\n    }\n}\nexports.ImageTimestampBase = ImageTimestampBase;\nImageTimestampBase.__name__ = \"ImageTimestampBase\";\nImageTimestampBase.init_ImageTimestampBase();\n//# sourceMappingURL=image_timestamp_base.js.map\n","type":"js","dependency_paths":[],"dependency_map":[],"externals":[],"shims":[]},"code":{"source":"/* image_timestamp_base.js */ function _(require, module, exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const tslib_1 = require(\"tslib\");\n    const xy_glyph_1 = require(\"@bokehjs/models/glyphs/xy_glyph\");\n    const types_1 = require(\"@bokehjs/core/types\");\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\n    const selection_1 = require(\"@bokehjs/models/selections/selection\");\n    const array_1 = require(\"@bokehjs/core/util/array\");\n    const ndarray_1 = require(\"@bokehjs/core/util/ndarray\");\n    const assert_1 = require(\"@bokehjs/core/util/assert\");\n    class ImageTimestampBaseView extends xy_glyph_1.XYGlyphView {\n        constructor(options) {\n            super(options);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n            this.connect(this.model.properties.time_stamp.change, () => {\n                // this.renderer.set_data()\n                this.renderer.request_render();\n            });\n        }\n        _render(ctx, indices, { image_data, sx, sy, sw, sh }) {\n            const old_smoothing = ctx.getImageSmoothingEnabled();\n            ctx.setImageSmoothingEnabled(false);\n            ctx.globalAlpha = this.model.global_alpha;\n            for (const i of indices) {\n                if (image_data[i] == null || isNaN(sx[i] + sy[i] + sw[i] + sh[i]))\n                    continue;\n                const y_offset = sy[i];\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n            }\n            ctx.setImageSmoothingEnabled(old_smoothing);\n        }\n        _set_data(indices) {\n            console.log(\"_set_data\");\n            this._set_width_heigh_data();\n            for (let i = 0, end = this._image.length; i < end; i++) {\n                if (indices != null && indices.indexOf(i) < 0)\n                    continue;\n                const img = this._image[i](this.model.time_stamp);\n                let flat_img;\n                if (ndarray_1.is_NDArray(img)) {\n                    assert_1.assert(img.dimension == 2, \"expected a 2D array\");\n                    flat_img = img;\n                    this._height[i] = img.shape[0];\n                    this._width[i] = img.shape[1];\n                }\n                else {\n                    flat_img = array_1.concat(img);\n                    this._height[i] = img.length;\n                    this._width[i] = img[0].length;\n                }\n                const buf8 = this._flat_img_to_buf8(flat_img);\n                this._set_image_data_from_buffer(i, buf8);\n            }\n        }\n        _index_data(index) {\n            const { data_size } = this;\n            for (let i = 0; i < data_size; i++) {\n                const [l, r, t, b] = this._lrtb(i);\n                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b))\n                    index.add_empty();\n                else\n                    index.add(l, b, r, t);\n            }\n        }\n        _lrtb(i) {\n            const xr = this.renderer.xscale.source_range;\n            const x1 = this._x[i];\n            const x2 = xr.is_reversed ? x1 - this._dw[i] : x1 + this._dw[i];\n            const yr = this.renderer.yscale.source_range;\n            const y1 = this._y[i];\n            const y2 = yr.is_reversed ? y1 - this._dh[i] : y1 + this._dh[i];\n            const [l, r] = x1 < x2 ? [x1, x2] : [x2, x1];\n            const [b, t] = y1 < y2 ? [y1, y2] : [y2, y1];\n            return [l, r, t, b];\n        }\n        _set_width_heigh_data() {\n            if (this.image_data == null || this.image_data.length != this._image.length)\n                this.image_data = new Array(this._image.length);\n            if (this._width == null || this._width.length != this._image.length)\n                this._width = new types_1.NumberArray(this._image.length);\n            if (this._height == null || this._height.length != this._image.length)\n                this._height = new types_1.NumberArray(this._image.length);\n        }\n        _get_or_create_canvas(i) {\n            const _image_data = this.image_data[i];\n            if (_image_data != null && _image_data.width == this._width[i] &&\n                _image_data.height == this._height[i])\n                return _image_data;\n            else {\n                const canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n                return canvas;\n            }\n        }\n        _set_image_data_from_buffer(i, buf8) {\n            const canvas = this._get_or_create_canvas(i);\n            const ctx = canvas.getContext('2d');\n            const image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n        }\n        _map_data() {\n            switch (this.model.properties.dw.units) {\n                case \"data\": {\n                    this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sw = this._dw;\n                    break;\n                }\n            }\n            switch (this.model.properties.dh.units) {\n                case \"data\": {\n                    this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sh = this._dh;\n                    break;\n                }\n            }\n        }\n        _image_index(index, x, y) {\n            const [l, r, t, b] = this._lrtb(index);\n            const width = this._width[index];\n            const height = this._height[index];\n            const dx = (r - l) / width;\n            const dy = (t - b) / height;\n            let dim1 = Math.floor((x - l) / dx);\n            let dim2 = Math.floor((y - b) / dy);\n            if (this.renderer.xscale.source_range.is_reversed)\n                dim1 = width - dim1 - 1;\n            if (this.renderer.yscale.source_range.is_reversed)\n                dim2 = height - dim2 - 1;\n            return { index, dim1, dim2, flat_index: dim2 * width + dim1 };\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const candidates = this.index.indices({ x0: x, x1: x, y0: y, y1: y });\n            const result = new selection_1.Selection();\n            for (const index of candidates) {\n                if (sx != Infinity && sy != Infinity) {\n                    result.image_indices.push(this._image_index(index, x, y));\n                }\n            }\n            return result;\n        }\n    }\n    exports.ImageTimestampBaseView = ImageTimestampBaseView;\n    ImageTimestampBaseView.__name__ = \"ImageTimestampBaseView\";\n    class ImageTimestampBase extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageTimestampBase() {\n            this.define({\n                image: [p.NDArraySpec],\n                dw: [p.DistanceSpec],\n                dh: [p.DistanceSpec],\n                dilate: [p.Boolean, false],\n                global_alpha: [p.Number, 1.0],\n                time_stamp: [p.Number, 1.0],\n            });\n        }\n    }\n    exports.ImageTimestampBase = ImageTimestampBase;\n    ImageTimestampBase.__name__ = \"ImageTimestampBase\";\n    ImageTimestampBase.init_ImageTimestampBase();\n}\n","min_source":"function _(e,t,s){Object.defineProperty(s,\"__esModule\",{value:!0});const i=e(\"tslib\"),a=e(\"@bokehjs/models/glyphs/xy_glyph\"),h=e(\"@bokehjs/core/types\"),r=i.__importStar(e(\"@bokehjs/core/properties\")),n=e(\"@bokehjs/models/selections/selection\"),_=e(\"@bokehjs/core/util/array\"),d=e(\"@bokehjs/core/util/ndarray\"),l=e(\"@bokehjs/core/util/assert\");class o extends a.XYGlyphView{constructor(e){super(e)}connect_signals(){super.connect_signals(),this.connect(this.model.properties.global_alpha.change,()=>this.renderer.request_render()),this.connect(this.model.properties.time_stamp.change,()=>{this.renderer.request_render()})}_render(e,t,{image_data:s,sx:i,sy:a,sw:h,sh:r}){const n=e.getImageSmoothingEnabled();e.setImageSmoothingEnabled(!1),e.globalAlpha=this.model.global_alpha;for(const n of t){if(null==s[n]||isNaN(i[n]+a[n]+h[n]+r[n]))continue;const t=a[n];e.translate(0,t),e.scale(1,-1),e.translate(0,-t),e.drawImage(s[n],0|i[n],0|a[n],h[n],r[n]),e.translate(0,t),e.scale(1,-1),e.translate(0,-t)}e.setImageSmoothingEnabled(n)}_set_data(e){console.log(\"_set_data\"),this._set_width_heigh_data();for(let t=0,s=this._image.length;t<s;t++){if(null!=e&&e.indexOf(t)<0)continue;const s=this._image[t](this.model.time_stamp);let i;d.is_NDArray(s)?(l.assert(2==s.dimension,\"expected a 2D array\"),i=s,this._height[t]=s.shape[0],this._width[t]=s.shape[1]):(i=_.concat(s),this._height[t]=s.length,this._width[t]=s[0].length);const a=this._flat_img_to_buf8(i);this._set_image_data_from_buffer(t,a)}}_index_data(e){const{data_size:t}=this;for(let s=0;s<t;s++){const[t,i,a,h]=this._lrtb(s);isNaN(t+i+a+h)||!isFinite(t+i+a+h)?e.add_empty():e.add(t,h,i,a)}}_lrtb(e){const t=this.renderer.xscale.source_range,s=this._x[e],i=t.is_reversed?s-this._dw[e]:s+this._dw[e],a=this.renderer.yscale.source_range,h=this._y[e],r=a.is_reversed?h-this._dh[e]:h+this._dh[e],[n,_]=s<i?[s,i]:[i,s],[d,l]=h<r?[h,r]:[r,h];return[n,_,l,d]}_set_width_heigh_data(){null!=this.image_data&&this.image_data.length==this._image.length||(this.image_data=new Array(this._image.length)),null!=this._width&&this._width.length==this._image.length||(this._width=new h.NumberArray(this._image.length)),null!=this._height&&this._height.length==this._image.length||(this._height=new h.NumberArray(this._image.length))}_get_or_create_canvas(e){const t=this.image_data[e];if(null!=t&&t.width==this._width[e]&&t.height==this._height[e])return t;{const t=document.createElement(\"canvas\");return t.width=this._width[e],t.height=this._height[e],t}}_set_image_data_from_buffer(e,t){const s=this._get_or_create_canvas(e),i=s.getContext(\"2d\"),a=i.getImageData(0,0,this._width[e],this._height[e]);a.data.set(t),i.putImageData(a,0,0),this.image_data[e]=s}_map_data(){switch(this.model.properties.dw.units){case\"data\":this.sw=this.sdist(this.renderer.xscale,this._x,this._dw,\"edge\",this.model.dilate);break;case\"screen\":this.sw=this._dw}switch(this.model.properties.dh.units){case\"data\":this.sh=this.sdist(this.renderer.yscale,this._y,this._dh,\"edge\",this.model.dilate);break;case\"screen\":this.sh=this._dh}}_image_index(e,t,s){const[i,a,h,r]=this._lrtb(e),n=this._width[e],_=this._height[e],d=(a-i)/n,l=(h-r)/_;let o=Math.floor((t-i)/d),c=Math.floor((s-r)/l);return this.renderer.xscale.source_range.is_reversed&&(o=n-o-1),this.renderer.yscale.source_range.is_reversed&&(c=_-c-1),{index:e,dim1:o,dim2:c,flat_index:c*n+o}}_hit_point(e){const{sx:t,sy:s}=e,i=this.renderer.xscale.invert(t),a=this.renderer.yscale.invert(s),h=this.index.indices({x0:i,x1:i,y0:a,y1:a}),r=new n.Selection;for(const e of h)t!=1/0&&s!=1/0&&r.image_indices.push(this._image_index(e,i,a));return r}}s.ImageTimestampBaseView=o,o.__name__=\"ImageTimestampBaseView\";class c extends a.XYGlyph{constructor(e){super(e)}static init_ImageTimestampBase(){this.define({image:[r.NDArraySpec],dw:[r.DistanceSpec],dh:[r.DistanceSpec],dilate:[r.Boolean,!1],global_alpha:[r.Number,1],time_stamp:[r.Number,1]})}}s.ImageTimestampBase=c,c.__name__=\"ImageTimestampBase\",c.init_ImageTimestampBase()}\n//# sourceMappingURL=image_timestamp_base.min.js.map","min_map":"{\"version\":3,\"sources\":[\"0\"],\"names\":[\"_\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"tslib_1\",\"xy_glyph_1\",\"types_1\",\"p\",\"__importStar\",\"selection_1\",\"array_1\",\"ndarray_1\",\"assert_1\",\"ImageTimestampBaseView\",\"XYGlyphView\",\"[object Object]\",\"options\",\"super\",\"connect_signals\",\"this\",\"connect\",\"model\",\"properties\",\"global_alpha\",\"change\",\"renderer\",\"request_render\",\"time_stamp\",\"ctx\",\"indices\",\"image_data\",\"sx\",\"sy\",\"sw\",\"sh\",\"old_smoothing\",\"getImageSmoothingEnabled\",\"setImageSmoothingEnabled\",\"globalAlpha\",\"i\",\"isNaN\",\"y_offset\",\"translate\",\"scale\",\"drawImage\",\"console\",\"log\",\"_set_width_heigh_data\",\"end\",\"_image\",\"length\",\"indexOf\",\"img\",\"flat_img\",\"is_NDArray\",\"assert\",\"dimension\",\"_height\",\"shape\",\"_width\",\"concat\",\"buf8\",\"_flat_img_to_buf8\",\"_set_image_data_from_buffer\",\"index\",\"data_size\",\"l\",\"r\",\"t\",\"b\",\"_lrtb\",\"isFinite\",\"add_empty\",\"add\",\"xr\",\"xscale\",\"source_range\",\"x1\",\"_x\",\"x2\",\"is_reversed\",\"_dw\",\"yr\",\"yscale\",\"y1\",\"_y\",\"y2\",\"_dh\",\"Array\",\"NumberArray\",\"_image_data\",\"width\",\"height\",\"canvas\",\"document\",\"createElement\",\"_get_or_create_canvas\",\"getContext\",\"getImageData\",\"data\",\"set\",\"putImageData\",\"dw\",\"units\",\"sdist\",\"dilate\",\"dh\",\"x\",\"y\",\"dx\",\"dy\",\"dim1\",\"Math\",\"floor\",\"dim2\",\"flat_index\",\"geometry\",\"invert\",\"candidates\",\"x0\",\"y0\",\"result\",\"Selection\",\"Infinity\",\"image_indices\",\"push\",\"_image_index\",\"__name__\",\"ImageTimestampBase\",\"XYGlyph\",\"attrs\",\"define\",\"image\",\"NDArraySpec\",\"DistanceSpec\",\"Boolean\",\"Number\",\"init_ImageTimestampBase\"],\"mappings\":\"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\",\"file\":\"image_timestamp_base.min.js\"}"}}]}