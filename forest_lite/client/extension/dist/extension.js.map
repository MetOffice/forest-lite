{"version":3,"sources":["@@/dist/lib/index.js","@@/dist/lib/image_timestamp.js","@@/dist/lib/image_timestamp_base.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* index.js */ function _(require, module, exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var image_timestamp_1 = require(\"4f96ca39c4\") /* ./image_timestamp */;\n    exports.ImageTimestamp = image_timestamp_1.ImageTimestamp;\n}\n","/* image_timestamp.js */ function _(require, module, exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const image_timestamp_base_1 = require(\"f9514df777\") /* ./image_timestamp_base */;\n    const color_mapper_1 = require(\"@bokehjs/models/mappers/color_mapper\");\n    const linear_color_mapper_1 = require(\"@bokehjs/models/mappers/linear_color_mapper\");\n    class ImageView extends image_timestamp_base_1.ImageTimestampBaseView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.color_mapper.change, () => this._update_image());\n        }\n        initialize() {\n            super.initialize();\n            // Game loop ?\n            window.requestAnimationFrame(this._frame);\n        }\n        _frame(timeStamp) {\n            console.log(timeStamp);\n        }\n        _update_image() {\n            // Only reset image_data if already initialized\n            if (this.image_data != null) {\n                this._set_data(null);\n                this.renderer.plot_view.request_render();\n            }\n        }\n        _flat_img_to_buf8(img) {\n            const cmap = this.model.color_mapper.rgba_mapper;\n            return cmap.v_compute(img);\n        }\n    }\n    exports.ImageView = ImageView;\n    ImageView.__name__ = \"ImageView\";\n    // NOTE: this needs to be redefined here, because palettes are located in bokeh-api.js bundle\n    const Greys9 = () => [\"#000000\", \"#252525\", \"#525252\", \"#737373\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\", \"#f0f0f0\", \"#ffffff\"];\n    class ImageTimestamp extends image_timestamp_base_1.ImageTimestampBase {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageTimestamp() {\n            this.prototype.default_view = ImageView;\n            this.define(({ Ref }) => ({\n                color_mapper: [Ref(color_mapper_1.ColorMapper), () => new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() })],\n            }));\n        }\n    }\n    exports.ImageTimestamp = ImageTimestamp;\n    ImageTimestamp.__name__ = \"ImageTimestamp\";\n    ImageTimestamp.init_ImageTimestamp();\n}\n","/* image_timestamp_base.js */ function _(require, module, exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const tslib_1 = require(\"tslib\");\n    const xy_glyph_1 = require(\"@bokehjs/models/glyphs/xy_glyph\");\n    const types_1 = require(\"@bokehjs/core/types\");\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\n    const selection_1 = require(\"@bokehjs/models/selections/selection\");\n    const array_1 = require(\"@bokehjs/core/util/array\");\n    const ndarray_1 = require(\"@bokehjs/core/util/ndarray\");\n    const assert_1 = require(\"@bokehjs/core/util/assert\");\n    class ImageTimestampBaseView extends xy_glyph_1.XYGlyphView {\n        constructor(options) {\n            super(options);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n            this.connect(this.model.properties.time_stamp.change, () => {\n                // this.renderer.set_data()\n                this.renderer.request_render();\n            });\n        }\n        _render(ctx, indices, { image_data, sx, sy, sw, sh }) {\n            const old_smoothing = ctx.getImageSmoothingEnabled();\n            ctx.setImageSmoothingEnabled(false);\n            ctx.globalAlpha = this.model.global_alpha;\n            for (const i of indices) {\n                if (image_data[i] == null || isNaN(sx[i] + sy[i] + sw[i] + sh[i]))\n                    continue;\n                const y_offset = sy[i];\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n            }\n            ctx.setImageSmoothingEnabled(old_smoothing);\n        }\n        _set_data(indices) {\n            console.log(\"_set_data\");\n            this._set_width_heigh_data();\n            for (let i = 0, end = this._image.length; i < end; i++) {\n                if (indices != null && indices.indexOf(i) < 0)\n                    continue;\n                const img = this._image[i](this.model.time_stamp);\n                let flat_img;\n                if (ndarray_1.is_NDArray(img)) {\n                    assert_1.assert(img.dimension == 2, \"expected a 2D array\");\n                    flat_img = img;\n                    this._height[i] = img.shape[0];\n                    this._width[i] = img.shape[1];\n                }\n                else {\n                    flat_img = array_1.concat(img);\n                    this._height[i] = img.length;\n                    this._width[i] = img[0].length;\n                }\n                const buf8 = this._flat_img_to_buf8(flat_img);\n                this._set_image_data_from_buffer(i, buf8);\n            }\n        }\n        _index_data(index) {\n            const { data_size } = this;\n            for (let i = 0; i < data_size; i++) {\n                const [l, r, t, b] = this._lrtb(i);\n                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b))\n                    index.add_empty();\n                else\n                    index.add(l, b, r, t);\n            }\n        }\n        _lrtb(i) {\n            const xr = this.renderer.xscale.source_range;\n            const x1 = this._x[i];\n            const x2 = xr.is_reversed ? x1 - this._dw[i] : x1 + this._dw[i];\n            const yr = this.renderer.yscale.source_range;\n            const y1 = this._y[i];\n            const y2 = yr.is_reversed ? y1 - this._dh[i] : y1 + this._dh[i];\n            const [l, r] = x1 < x2 ? [x1, x2] : [x2, x1];\n            const [b, t] = y1 < y2 ? [y1, y2] : [y2, y1];\n            return [l, r, t, b];\n        }\n        _set_width_heigh_data() {\n            if (this.image_data == null || this.image_data.length != this._image.length)\n                this.image_data = new Array(this._image.length);\n            if (this._width == null || this._width.length != this._image.length)\n                this._width = new types_1.NumberArray(this._image.length);\n            if (this._height == null || this._height.length != this._image.length)\n                this._height = new types_1.NumberArray(this._image.length);\n        }\n        _get_or_create_canvas(i) {\n            const _image_data = this.image_data[i];\n            if (_image_data != null && _image_data.width == this._width[i] &&\n                _image_data.height == this._height[i])\n                return _image_data;\n            else {\n                const canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n                return canvas;\n            }\n        }\n        _set_image_data_from_buffer(i, buf8) {\n            const canvas = this._get_or_create_canvas(i);\n            const ctx = canvas.getContext('2d');\n            const image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n        }\n        _map_data() {\n            switch (this.model.properties.dw.units) {\n                case \"data\": {\n                    this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sw = this._dw;\n                    break;\n                }\n            }\n            switch (this.model.properties.dh.units) {\n                case \"data\": {\n                    this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sh = this._dh;\n                    break;\n                }\n            }\n        }\n        _image_index(index, x, y) {\n            const [l, r, t, b] = this._lrtb(index);\n            const width = this._width[index];\n            const height = this._height[index];\n            const dx = (r - l) / width;\n            const dy = (t - b) / height;\n            let dim1 = Math.floor((x - l) / dx);\n            let dim2 = Math.floor((y - b) / dy);\n            if (this.renderer.xscale.source_range.is_reversed)\n                dim1 = width - dim1 - 1;\n            if (this.renderer.yscale.source_range.is_reversed)\n                dim2 = height - dim2 - 1;\n            return { index, dim1, dim2, flat_index: dim2 * width + dim1 };\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const candidates = this.index.indices({ x0: x, x1: x, y0: y, y1: y });\n            const result = new selection_1.Selection();\n            for (const index of candidates) {\n                if (sx != Infinity && sy != Infinity) {\n                    result.image_indices.push(this._image_index(index, x, y));\n                }\n            }\n            return result;\n        }\n    }\n    exports.ImageTimestampBaseView = ImageTimestampBaseView;\n    ImageTimestampBaseView.__name__ = \"ImageTimestampBaseView\";\n    class ImageTimestampBase extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageTimestampBase() {\n            this.define({\n                image: [p.NDArraySpec],\n                dw: [p.DistanceSpec],\n                dh: [p.DistanceSpec],\n                dilate: [p.Boolean, false],\n                global_alpha: [p.Number, 1.0],\n                time_stamp: [p.Number, 1.0],\n            });\n        }\n    }\n    exports.ImageTimestampBase = ImageTimestampBase;\n    ImageTimestampBase.__name__ = \"ImageTimestampBase\";\n    ImageTimestampBase.init_ImageTimestampBase();\n}\n"]}