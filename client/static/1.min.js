(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{188:function(t,e,n){"use strict";n.r(e),n.d(e,"LineGLGlyph",(function(){return k})),n.d(e,"MarkerGLGlyph",(function(){return R})),n.d(e,"CircleGLGlyph",(function(){return j})),n.d(e,"SquareGLGlyph",(function(){return G})),n.d(e,"DiamondGLGlyph",(function(){return L})),n.d(e,"TriangleGLGlyph",(function(){return O})),n.d(e,"InvertedTriangleGLGlyph",(function(){return D})),n.d(e,"HexGLGlyph",(function(){return M})),n.d(e,"CrossGLGlyph",(function(){return F})),n.d(e,"CircleCrossGLGlyph",(function(){return V})),n.d(e,"SquareCrossGLGlyph",(function(){return C})),n.d(e,"DiamondCrossGLGlyph",(function(){return B})),n.d(e,"XGLGlyph",(function(){return N})),n.d(e,"CircleXGLGlyph",(function(){return U})),n.d(e,"SquareXGLGlyph",(function(){return Q})),n.d(e,"AsteriskGLGlyph",(function(){return X}));var a=n(3),s=n.n(a),i=n(5),r=n.n(i),o=n(0),l=n.n(o),_=n(6),h=n.n(_),c=n(2),f=n.n(c),u=n(4),d=n.n(u),v=n(189),g=n(52),p=n(15),y=function(){function t(e,n){f()(this,t),this.gl=e,this.glyph=n,this.nvertices=0,this.size_changed=!1,this.data_changed=!1,this.visuals_changed=!1,this.init()}return d()(t,[{key:"set_data_changed",value:function(t){t!=this.nvertices&&(this.nvertices=t,this.size_changed=!0),this.data_changed=!0}},{key:"set_visuals_changed",value:function(){this.visuals_changed=!0}},{key:"render",value:function(t,e,n){if(0==e.length)return!0;var a=1,s=1,i=this.glyph.renderer.map_to_screen([0*a,1*a,2*a],[0*s,1*s,2*s]),r=h()(i,2),o=r[0],l=r[1];if(isNaN(o[0]+o[1]+o[2]+l[0]+l[1]+l[2]))return p.a.warn("WebGL backend (".concat(this.glyph.model.type,"): falling back to canvas rendering")),!1;a=100/Math.min(Math.max(Math.abs(o[1]-o[0]),1e-12),1e12),s=100/Math.min(Math.max(Math.abs(l[1]-l[0]),1e-12),1e12);var _=this.glyph.renderer.map_to_screen([0*a,1*a,2*a],[0*s,1*s,2*s]),c=h()(_,2);if(o=c[0],l=c[1],Math.abs(o[1]-o[0]-(o[2]-o[1]))>1e-6||Math.abs(l[1]-l[0]-(l[2]-l[1]))>1e-6)return p.a.warn("WebGL backend (".concat(this.glyph.model.type,"): falling back to canvas rendering")),!1;var f=(o[1]-o[0])/a,u=(l[1]-l[0])/s,d=this.glyph.renderer.plot_view.canvas_view.webgl.canvas,v=d.width,g=d.height,y={pixel_ratio:this.glyph.renderer.plot_view.canvas_view.pixel_ratio,width:v,height:g,dx:o[0]/f,dy:l[0]/u,sx:f,sy:u};return this.draw(e,n,y),!0}}]),t}();function m(t,e){return void 0!==t[e].spec.value}function x(t,e,n,a,s,i){var r,o=i+"_color",l=i+"_alpha";if(s.doit)if(m(s,o)&&m(s,l))e.used=!1,r=Object(g.c)(s[o].value(),s[l].value()),t.set_attribute(n,"vec4",r);else{var _,h;e.used=!0,h=m(s,o)?function(){for(var t=[],e=0,n=a;e<n;e++)t.push(s[o].value());return t}():s.get_array(o),_=m(s,l)?function(t,e){for(var n=new Float32Array(t),a=0,s=t;a<s;a++)n[a]=e;return n}(a,s[l].value()):s.get_array(l);for(var c=new Float32Array(4*a),f=0,u=a;f<u;f++){r=Object(g.c)(h[f],_[f]);for(var d=0;d<4;d++)c[4*f+d]=r[d]}e.set_size(4*a*4),e.set_data(0,c),t.set_attribute(n,"vec4",e)}else e.used=!1,t.set_attribute(n,"vec4",[0,0,0,0])}y.__name__="BaseGLGlyph";function b(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,a=l()(t);if(e){var s=l()(this).constructor;n=Reflect.construct(a,arguments,s)}else n=a.apply(this,arguments);return r()(this,n)}}function w(t,e){var n;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(n=function(t,e){if(!t)return;if("string"==typeof t)return P(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return P(t,e)}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var a=0,s=function(){};return{s:s,n:function(){return a>=t.length?{done:!0}:{done:!1,value:t[a++]}},e:function(t){throw t},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,r=!0,o=!1;return{s:function(){n=t[Symbol.iterator]()},n:function(){var t=n.next();return r=t.done,t},e:function(t){o=!0,i=t},f:function(){try{r||null==n.return||n.return()}finally{if(o)throw i}}}}function P(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,a=new Array(e);n<e;n++)a[n]=t[n];return a}var A=function(){function t(e){f()(this,t),this._atlas={},this._index=0,this._width=256,this._height=256,this.tex=new v.Texture2D(e),this.tex.set_wrapping(e.REPEAT,e.REPEAT),this.tex.set_interpolation(e.NEAREST,e.NEAREST),this.tex.set_size([this._height,this._width],e.RGBA),this.tex.set_data([0,0],[this._height,this._width],new Uint8Array(this._height*this._width*4)),this.get_atlas_data([1])}return d()(t,[{key:"get_atlas_data",value:function(t){var e=t.join("-");if(void 0===this._atlas[e]){var n=this.make_pattern(t),a=h()(n,2),s=a[0],i=a[1];this.tex.set_data([this._index,0],[1,this._width],new Uint8Array(s.map((function(t){return t+10})))),this._atlas[e]=[this._index/this._height,i],this._index+=1}return this._atlas[e]}},{key:"make_pattern",value:function(t){t.length>1&&t.length%2&&(t=t.concat(t));var e,n=0,a=w(t);try{for(a.s();!(e=a.n()).done;){n+=e.value}}catch(t){a.e(t)}finally{a.f()}for(var s=[],i=0,r=0,o=t.length+2;r<o;r+=2){var l=Math.max(1e-4,t[r%t.length]),_=Math.max(1e-4,t[(r+1)%t.length]);s.push(i,i+l),i+=l+_}for(var h=this._width,c=new Float32Array(4*h),f=0,u=h;f<u;f++){for(var d=void 0,v=void 0,g=void 0,p=n*f/(h-1),y=0,m=1e16,x=0,b=s.length;x<b;x++){var P=Math.abs(s[x]-p);P<m&&(y=x,m=P)}y%2==0?(g=p<=s[y]?1:0,v=s[y],d=s[y+1]):(g=p>s[y]?-1:0,v=s[y-1],d=s[y]),c[4*f+0]=s[y],c[4*f+1]=g,c[4*f+2]=v,c[4*f+3]=d}return[c,n]}}]),t}();A.__name__="DashAtlas";var z={miter:0,round:1,bevel:2},q={"":0,none:0,".":0,round:1,")":1,"(":1,o:1,"triangle in":2,"<":2,"triangle out":3,">":3,square:4,"[":4,"]":4,"=":4,butt:5,"|":5},k=function(t){s()(n,t);var e=b(n);function n(){return f()(this,n),e.apply(this,arguments)}return d()(n,[{key:"init",value:function(){var t=this.gl;this._scale_aspect=0;this.prog=new v.Program(t),this.prog.set_shaders("\nprecision mediump float;\n\nconst float PI = 3.14159265358979323846264;\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\n\nuniform float u_pixel_ratio;\nuniform vec2 u_canvas_size, u_offset;\nuniform vec2 u_scale_aspect;\nuniform float u_scale_length;\n\nuniform vec4 u_color;\nuniform float u_antialias;\nuniform float u_length;\nuniform float u_linewidth;\nuniform float u_dash_index;\nuniform float u_closed;\n\nattribute vec2 a_position;\nattribute vec4 a_tangents;\nattribute vec2 a_segment;\nattribute vec2 a_angles;\nattribute vec2 a_texcoord;\n\nvarying vec4  v_color;\nvarying vec2  v_segment;\nvarying vec2  v_angles;\nvarying vec2  v_texcoord;\nvarying vec2  v_miter;\nvarying float v_length;\nvarying float v_linewidth;\n\nfloat cross(in vec2 v1, in vec2 v2)\n{\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\n{\n    return cross(v2-v1,v1-v3) / length(v2-v1);\n}\n\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    result = vec2( c*v.x - s*v.y,\n                   s*v.x + c*v.y );\n}\n\nvoid main()\n{\n    bool closed = (u_closed > 0.0);\n\n    // Attributes and uniforms to varyings\n    v_color = u_color;\n    v_linewidth = u_linewidth;\n    v_segment = a_segment * u_scale_length;\n    v_length = u_length * u_scale_length;\n\n    // Scale to map to pixel coordinates. The original algorithm from the paper\n    // assumed isotropic scale. We obviously do not have this.\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\n\n    // Correct angles for aspect ratio\n    vec2 av;\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\n    v_angles.x = atan(av.y, av.x);\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\n    v_angles.y = atan(av.y, av.x);\n\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\n    // and a modified alpha\n    v_color.a = min(v_linewidth, v_color.a);\n    v_linewidth = max(v_linewidth, 1.0);\n\n    // If color is fully transparent we just will discard the fragment anyway\n    if( v_color.a <= 0.0 ) {\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n\n    // This is the actual half width of the line\n    float w = ceil(u_antialias+v_linewidth)/2.0;\n\n    vec2 position = (a_position + u_offset) * abs_scale;\n\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\n    float u = a_texcoord.x;\n    float v = a_texcoord.y;\n    vec2 o1 = vec2( +t1.y, -t1.x);\n    vec2 o2 = vec2( +t2.y, -t2.x);\n\n    // This is a join\n    // ----------------------------------------------------------------\n    if( t1 != t2 ) {\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\n        vec2 t  = normalize(t1+t2);\n        vec2 o  = vec2( + t.y, - t.x);\n\n        if ( u_dash_index > 0.0 )\n        {\n            // Broken angle\n            // ----------------------------------------------------------------\n            if( (abs(angle) > THETA) ) {\n                position += v * w * o / cos(angle/2.0);\n                float s = sign(angle);\n                if( angle < 0.0 ) {\n                    if( u == +1.0 ) {\n                        u = v_segment.y + v * w * tan(angle/2.0);\n                        if( v == 1.0 ) {\n                            position -= 2.0 * w * t1 / sin(angle);\n                            u -= 2.0 * w / sin(angle);\n                        }\n                    } else {\n                        u = v_segment.x - v * w * tan(angle/2.0);\n                        if( v == 1.0 ) {\n                            position += 2.0 * w * t2 / sin(angle);\n                            u += 2.0*w / sin(angle);\n                        }\n                    }\n                } else {\n                    if( u == +1.0 ) {\n                        u = v_segment.y + v * w * tan(angle/2.0);\n                        if( v == -1.0 ) {\n                            position += 2.0 * w * t1 / sin(angle);\n                            u += 2.0 * w / sin(angle);\n                        }\n                    } else {\n                        u = v_segment.x - v * w * tan(angle/2.0);\n                        if( v == -1.0 ) {\n                            position -= 2.0 * w * t2 / sin(angle);\n                            u -= 2.0*w / sin(angle);\n                        }\n                    }\n                }\n                // Continuous angle\n                // ------------------------------------------------------------\n            } else {\n                position += v * w * o / cos(angle/2.0);\n                if( u == +1.0 ) u = v_segment.y;\n                else            u = v_segment.x;\n            }\n        }\n\n        // Solid line\n        // --------------------------------------------------------------------\n        else\n        {\n            position.xy += v * w * o / cos(angle/2.0);\n            if( angle < 0.0 ) {\n                if( u == +1.0 ) {\n                    u = v_segment.y + v * w * tan(angle/2.0);\n                } else {\n                    u = v_segment.x - v * w * tan(angle/2.0);\n                }\n            } else {\n                if( u == +1.0 ) {\n                    u = v_segment.y + v * w * tan(angle/2.0);\n                } else {\n                    u = v_segment.x - v * w * tan(angle/2.0);\n                }\n            }\n        }\n\n    // This is a line start or end (t1 == t2)\n    // ------------------------------------------------------------------------\n    } else {\n        position += v * w * o1;\n        if( u == -1.0 ) {\n            u = v_segment.x - w;\n            position -= w * t1;\n        } else {\n            u = v_segment.y + w;\n            position += w * t2;\n        }\n    }\n\n    // Miter distance\n    // ------------------------------------------------------------------------\n    vec2 t;\n    vec2 curr = a_position * abs_scale;\n    if( a_texcoord.x < 0.0 ) {\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\n\n        rotate( t1, +v_angles.x/2.0, t);\n        v_miter.x = signed_distance(curr, curr+t, position);\n\n        rotate( t2, +v_angles.y/2.0, t);\n        v_miter.y = signed_distance(next, next+t, position);\n    } else {\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\n\n        rotate( t1, -v_angles.x/2.0,t);\n        v_miter.x = signed_distance(prev, prev+t, position);\n\n        rotate( t2, -v_angles.y/2.0,t);\n        v_miter.y = signed_distance(curr, curr+t, position);\n    }\n\n    if (!closed && v_segment.x <= 0.0) {\n        v_miter.x = 1e10;\n    }\n    if (!closed && v_segment.y >= v_length)\n    {\n        v_miter.y = 1e10;\n    }\n\n    v_texcoord = vec2( u, v*w );\n\n    // Calculate position in device coordinates. Note that we\n    // already scaled with abs scale above.\n    vec2 normpos = position * sign(u_scale_aspect);\n    normpos += 0.5;  // make up for Bokeh's offset\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\n    gl_Position.y *= -1.0;\n}\n","\nprecision mediump float;\n\nconst float PI = 3.14159265358979323846264;\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\n\nuniform sampler2D u_dash_atlas;\n\nuniform vec2 u_linecaps;\nuniform float u_miter_limit;\nuniform float u_linejoin;\nuniform float u_antialias;\nuniform float u_dash_phase;\nuniform float u_dash_period;\nuniform float u_dash_index;\nuniform vec2 u_dash_caps;\nuniform float u_closed;\n\nvarying vec4  v_color;\nvarying vec2  v_segment;\nvarying vec2  v_angles;\nvarying vec2  v_texcoord;\nvarying vec2  v_miter;\nvarying float v_length;\nvarying float v_linewidth;\n\n// Compute distance to cap ----------------------------------------------------\nfloat cap( int type, float dx, float dy, float t, float linewidth )\n{\n    float d = 0.0;\n    dx = abs(dx);\n    dy = abs(dy);\n    if      (type == 0)  discard;  // None\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\n    else if (type == 4)  d = max(dx,dy);  // Square\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\n    return d;\n}\n\n// Compute distance to join -------------------------------------------------\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\n           in float linewidth )\n{\n    // texcoord.x is distance from start\n    // texcoord.y is distance from centerline\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\n\n    float dx = texcoord.x;\n\n    // Round join\n    if( type == 1 ) {\n        if (dx < segment.x) {\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\n            //d = length( texcoord - vec2(segment.x,0.0));\n        } else if (dx > segment.y) {\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\n            //d = length( texcoord - vec2(segment.y,0.0));\n        }\n    }\n    // Bevel join\n    else if ( type == 2 ) {\n        if (dx < segment.x) {\n            vec2 x = texcoord - vec2(segment.x,0.0);\n            d = max(d, max(abs(x.x), abs(x.y)));\n\n        } else if (dx > segment.y) {\n            vec2 x = texcoord - vec2(segment.y,0.0);\n            d = max(d, max(abs(x.x), abs(x.y)));\n        }\n        /*  Original code for bevel which does not work for us\n        if( (dx < segment.x) ||  (dx > segment.y) )\n            d = max(d, min(abs(x.x),abs(x.y)));\n        */\n    }\n\n    return d;\n}\n\nvoid main()\n{\n    // If color is fully transparent we just discard the fragment\n    if( v_color.a <= 0.0 ) {\n        discard;\n    }\n\n    // Test if dash pattern is the solid one (0)\n    bool solid =  (u_dash_index == 0.0);\n\n    // Test if path is closed\n    bool closed = (u_closed > 0.0);\n\n    vec4 color = v_color;\n    float dx = v_texcoord.x;\n    float dy = v_texcoord.y;\n    float t = v_linewidth/2.0-u_antialias;\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\n    float d = 0.0;\n\n    vec2 linecaps = u_linecaps;\n    vec2 dash_caps = u_dash_caps;\n    float line_start = 0.0;\n    float line_stop = v_length;\n\n    // Apply miter limit; fragments too far into the miter are simply discarded\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\n          discard;\n    }\n\n    // Solid line --------------------------------------------------------------\n    if( solid ) {\n        d = abs(dy);\n        if( (!closed) && (dx < line_start) ) {\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\n        }\n        else if( (!closed) &&  (dx > line_stop) ) {\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\n        }\n        else {\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\n        }\n\n    // Dash line --------------------------------------------------------------\n    } else {\n        float segment_start = v_segment.x;\n        float segment_stop  = v_segment.y;\n        float segment_center= (segment_start+segment_stop)/2.0;\n        float freq          = u_dash_period*width;\n        float u = mod( dx + u_dash_phase*width, freq);\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n        float dash_center= tex.x * width;\n        float dash_type  = tex.y;\n        float _start = tex.z * width;\n        float _stop  = tex.a * width;\n        float dash_start = dx - u + _start;\n        float dash_stop  = dx - u + _stop;\n\n        // Compute extents of the first dash (the one relative to v_segment.x)\n        // Note: this could be computed in the vertex shader\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\n            float u = mod(segment_start + u_dash_phase*width, freq);\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n            dash_center= tex.x * width;\n            //dash_type  = tex.y;\n            float _start = tex.z * width;\n            float _stop  = tex.a * width;\n            dash_start = segment_start - u + _start;\n            dash_stop = segment_start - u + _stop;\n        }\n\n        // Compute extents of the last dash (the one relatives to v_segment.y)\n        // Note: This could be computed in the vertex shader\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\n            float u = mod(segment_stop + u_dash_phase*width, freq);\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n            dash_center= tex.x * width;\n            //dash_type  = tex.y;\n            float _start = tex.z * width;\n            float _stop  = tex.a * width;\n            dash_start = segment_stop - u + _start;\n            dash_stop  = segment_stop - u + _stop;\n        }\n\n        // This test if the we are dealing with a discontinuous angle\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\n        //if( dx < line_start) discontinuous = false;\n        //if( dx > line_stop)  discontinuous = false;\n\n        float d_join = join( int(u_linejoin), abs(dy),\n                            v_segment, v_texcoord, v_miter, v_linewidth );\n\n        // When path is closed, we do not have room for linecaps, so we make room\n        // by shortening the total length\n        if (closed) {\n             line_start += v_linewidth/2.0;\n             line_stop  -= v_linewidth/2.0;\n        }\n\n        // We also need to take antialias area into account\n        //line_start += u_antialias;\n        //line_stop  -= u_antialias;\n\n        // Check is dash stop is before line start\n        if( dash_stop <= line_start ) {\n            discard;\n        }\n        // Check is dash start is beyond line stop\n        if( dash_start >= line_stop ) {\n            discard;\n        }\n\n        // Check if current dash start is beyond segment stop\n        if( discontinuous ) {\n            // Dash start is beyond segment, we discard\n            if( (dash_start > segment_stop) ) {\n                discard;\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\n            }\n\n            // Dash stop is before segment, we discard\n            if( (dash_stop < segment_start) ) {\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\n            }\n\n            // Special case for round caps (nicer with this)\n            if( dash_caps.x == 1.0 ) {\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\n                    discard;\n                }\n            }\n\n            // Special case for round caps  (nicer with this)\n            if( dash_caps.y == 1.0 ) {\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\n                    discard;\n                }\n            }\n\n            // Special case for triangle caps (in & out) and square\n            // We make sure the cap stop at crossing frontier\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\n                    float a = v_angles.x/2.0;\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\n                    if( x > 0.0 ) discard;\n                    // We transform the cap into square to avoid holes\n                    dash_caps.x = 4.0;\n                }\n            }\n\n            // Special case for triangle caps (in & out) and square\n            // We make sure the cap stop at crossing frontier\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\n                    float a = v_angles.y/2.0;\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\n                    if( x > 0.0 ) discard;\n                    // We transform the caps into square to avoid holes\n                    dash_caps.y = 4.0;\n                }\n            }\n        }\n\n        // Line cap at start\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\n        }\n        // Line cap at stop\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\n        }\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\n        else if( dash_type < -0.5 ) {\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\n            if( (dx > line_start) && (dx < line_stop) )\n                d = max(d,d_join);\n        }\n        // Dash cap right\n        else if( dash_type > 0.5 ) {\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\n            if( (dx > line_start) && (dx < line_stop) )\n                d = max(d,d_join);\n        }\n        // Dash body (plain)\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\n            d = abs(dy);\n        }\n\n        // Line join\n        if( (dx > line_start) && (dx < line_stop)) {\n            if( (dx <= segment_start) && (dash_start <= segment_start)\n                && (dash_stop >= segment_start) ) {\n                d = d_join;\n                // Antialias at outer border\n                float angle = PI/2.+v_angles.x;\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\n                d = max(f,d);\n            }\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\n                     && (dash_stop >= segment_stop) ) {\n                d = d_join;\n                // Antialias at outer border\n                float angle = PI/2.+v_angles.y;\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\n                d = max(f,d);\n            }\n            else if( dx < (segment_start - v_linewidth/2.)) {\n                discard;\n            }\n            else if( dx > (segment_stop + v_linewidth/2.)) {\n                discard;\n            }\n        }\n        else if( dx < (segment_start - v_linewidth/2.)) {\n            discard;\n        }\n        else if( dx > (segment_stop + v_linewidth/2.)) {\n            discard;\n        }\n    }\n\n    // Distance to border ------------------------------------------------------\n    d = d - t;\n    if( d < 0.0 ) {\n        gl_FragColor = color;\n    } else {\n        d /= u_antialias;\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\n    }\n}\n"),this.index_buffer=new v.IndexBuffer(t),this.vbo_position=new v.VertexBuffer(t),this.vbo_tangents=new v.VertexBuffer(t),this.vbo_segment=new v.VertexBuffer(t),this.vbo_angles=new v.VertexBuffer(t),this.vbo_texcoord=new v.VertexBuffer(t),this.dash_atlas=new A(t)}},{key:"draw",value:function(t,e,n){var a=e.glglyph;if(a.data_changed){if(!isFinite(n.dx)||!isFinite(n.dy))return;a._baked_offset=[n.dx,n.dy],a._set_data(),a.data_changed=!1}this.visuals_changed&&(this._set_visuals(),this.visuals_changed=!1);var s=n.sx,i=n.sy,r=Math.sqrt(s*s+i*i);s/=r,i/=r,Math.abs(this._scale_aspect-i/s)>Math.abs(.001*this._scale_aspect)&&(a._update_scale(s,i),this._scale_aspect=i/s),this.prog.set_attribute("a_position","vec2",a.vbo_position),this.prog.set_attribute("a_tangents","vec4",a.vbo_tangents),this.prog.set_attribute("a_segment","vec2",a.vbo_segment),this.prog.set_attribute("a_angles","vec2",a.vbo_angles),this.prog.set_attribute("a_texcoord","vec2",a.vbo_texcoord),this.prog.set_uniform("u_length","float",[a.cumsum]),this.prog.set_texture("u_dash_atlas",this.dash_atlas.tex);var o=a._baked_offset;if(this.prog.set_uniform("u_pixel_ratio","float",[n.pixel_ratio]),this.prog.set_uniform("u_canvas_size","vec2",[n.width,n.height]),this.prog.set_uniform("u_offset","vec2",[n.dx-o[0],n.dy-o[1]]),this.prog.set_uniform("u_scale_aspect","vec2",[s,i]),this.prog.set_uniform("u_scale_length","float",[r]),this.I_triangles=a.I_triangles,this.I_triangles.length<65535)this.index_buffer.set_size(2*this.I_triangles.length),this.index_buffer.set_data(0,new Uint16Array(this.I_triangles)),this.prog.draw(this.gl.TRIANGLES,this.index_buffer);else{t=Array.from(this.I_triangles);for(var l=this.I_triangles.length,_=[],h=0,c=Math.ceil(l/64008);h<c;h++)_.push([]);for(var f=0,u=t.length;f<u;f++){var d=t[f]%64008;_[Math.floor(t[f]/64008)].push(d)}for(var v=0,g=_.length;v<g;v++){var p=new Uint16Array(_[v]),y=64008*v*4;0!==p.length&&(this.prog.set_attribute("a_position","vec2",a.vbo_position,0,2*y),this.prog.set_attribute("a_tangents","vec4",a.vbo_tangents,0,4*y),this.prog.set_attribute("a_segment","vec2",a.vbo_segment,0,2*y),this.prog.set_attribute("a_angles","vec2",a.vbo_angles,0,2*y),this.prog.set_attribute("a_texcoord","vec2",a.vbo_texcoord,0,2*y),this.index_buffer.set_size(2*p.length),this.index_buffer.set_data(0,p),this.prog.draw(this.gl.TRIANGLES,this.index_buffer))}}}},{key:"_set_data",value:function(){this._bake(),this.vbo_position.set_size(4*this.V_position.length),this.vbo_position.set_data(0,this.V_position),this.vbo_tangents.set_size(4*this.V_tangents.length),this.vbo_tangents.set_data(0,this.V_tangents),this.vbo_angles.set_size(4*this.V_angles.length),this.vbo_angles.set_data(0,this.V_angles),this.vbo_texcoord.set_size(4*this.V_texcoord.length),this.vbo_texcoord.set_data(0,this.V_texcoord)}},{key:"_set_visuals",value:function(){var t=Object(g.c)(this.glyph.visuals.line.line_color.value(),this.glyph.visuals.line.line_alpha.value()),e=q[this.glyph.visuals.line.line_cap.value()],n=z[this.glyph.visuals.line.line_join.value()];this.prog.set_uniform("u_color","vec4",t),this.prog.set_uniform("u_linewidth","float",[this.glyph.visuals.line.line_width.value()]),this.prog.set_uniform("u_antialias","float",[.9]),this.prog.set_uniform("u_linecaps","vec2",[e,e]),this.prog.set_uniform("u_linejoin","float",[n]),this.prog.set_uniform("u_miter_limit","float",[10]);var a=this.glyph.visuals.line.line_dash.value(),s=0,i=1;if(a.length){var r=this.dash_atlas.get_atlas_data(a),o=h()(r,2);s=o[0],i=o[1]}this.prog.set_uniform("u_dash_index","float",[s]),this.prog.set_uniform("u_dash_phase","float",[this.glyph.visuals.line.line_dash_offset.value()]),this.prog.set_uniform("u_dash_period","float",[i]),this.prog.set_uniform("u_dash_caps","vec2",[e,e]),this.prog.set_uniform("u_closed","float",[0])}},{key:"_bake",value:function(){for(var t,e,n,a,s,i,r,o,l=this.nvertices,_=new Float64Array(this.glyph._x),h=new Float64Array(this.glyph._y),c=r=new Float32Array(2*l),f=new Float32Array(2*l),u=o=new Float32Array(4*l),d=0,v=l;d<v;d++)c[2*d+0]=_[d]+this._baked_offset[0],c[2*d+1]=h[d]+this._baked_offset[1];this.tangents=e=new Float32Array(2*l-2);for(var g=0,p=l-1;g<p;g++)e[2*g+0]=r[2*(g+1)+0]-r[2*g+0],e[2*g+1]=r[2*(g+1)+1]-r[2*g+1];for(var y=0,m=l-1;y<m;y++)u[4*(y+1)+0]=e[2*y+0],u[4*(y+1)+1]=e[2*y+1],u[4*y+2]=e[2*y+0],u[4*y+3]=e[2*y+1];u[0]=e[0],u[1]=e[1],u[4*(l-1)+2]=e[2*(l-2)+0],u[4*(l-1)+3]=e[2*(l-2)+1];for(var x=new Float32Array(l),b=0,w=l;b<w;b++)x[b]=Math.atan2(o[4*b+0]*o[4*b+3]-o[4*b+1]*o[4*b+2],o[4*b+0]*o[4*b+2]+o[4*b+1]*o[4*b+3]);for(var P=0,A=l-1;P<A;P++)f[2*P+0]=x[P],f[2*P+1]=x[P+1];var z=4*l-4;this.V_position=a=new Float32Array(2*z),this.V_angles=n=new Float32Array(2*z),this.V_tangents=s=new Float32Array(4*z),this.V_texcoord=i=new Float32Array(2*z);for(var q=0,k=l;q<k;q++)for(var T=0;T<4;T++){for(var E=0;E<2;E++)a[2*(4*q+T-2)+E]=c[2*q+E],n[2*(4*q+T)+E]=f[2*q+E];for(var S=0;S<4;S++)s[4*(4*q+T-2)+S]=u[4*q+S]}for(var R=0,I=l;R<I;R++)i[2*(4*R+0)+0]=-1,i[2*(4*R+1)+0]=-1,i[2*(4*R+2)+0]=1,i[2*(4*R+3)+0]=1,i[2*(4*R+0)+1]=-1,i[2*(4*R+1)+1]=1,i[2*(4*R+2)+1]=-1,i[2*(4*R+3)+1]=1;var j=6*(l-1);this.I_triangles=t=new Uint32Array(j);for(var G=0,L=l;G<L;G++)t[6*G+0]=0+4*G,t[6*G+1]=1+4*G,t[6*G+2]=3+4*G,t[6*G+3]=2+4*G,t[6*G+4]=0+4*G,t[6*G+5]=3+4*G}},{key:"_update_scale",value:function(t,e){var n,a=this.nvertices,s=4*a-4,i=this.tangents,r=new Float32Array(a-1),o=new Float32Array(2*a);this.V_segment=n=new Float32Array(2*s);for(var l=0,_=a-1;l<_;l++)r[l]=Math.sqrt(Math.pow(i[2*l+0]*t,2)+Math.pow(i[2*l+1]*e,2));for(var h=0,c=0,f=a-1;c<f;c++)h+=r[c],o[2*(c+1)+0]=h,o[2*c+1]=h;for(var u=0,d=a;u<d;u++)for(var v=0;v<4;v++)for(var g=0;g<2;g++)n[2*(4*u+v)+g]=o[2*u+g];this.cumsum=h,this.vbo_segment.set_size(4*this.V_segment.length),this.vbo_segment.set_data(0,this.V_segment)}}]),n}(y);k.__name__="LineGLGlyph";var T=n(123),E=n(17);function S(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,a=l()(t);if(e){var s=l()(this).constructor;n=Reflect.construct(a,arguments,s)}else n=a.apply(this,arguments);return r()(this,n)}}var R=function(t){s()(n,t);var e=S(n);function n(){return f()(this,n),e.apply(this,arguments)}return d()(n,[{key:"init",value:function(){var t,e=this.gl,n=(t=this._marker_code,"\nprecision mediump float;\nconst float SQRT_2 = 1.4142135623730951;\nconst float PI = 3.14159265358979323846264;\n//\nuniform float u_antialias;\n//\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying float v_linewidth;\nvarying float v_size;\nvarying vec2  v_rotation;\n\n".concat(t,"\n\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\n    float select = float(bool(fg_color.a));\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\n    // Similarly, if we want a transparent bg\n    select = float(bool(bg_color.a));\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\n\n    if( border_distance < 0.0)\n        frag_color = fg_color;\n    else if( signed_distance < 0.0 ) {\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\n    } else {\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\n        } else {\n            discard;\n        }\n    }\n    return frag_color;\n}\n\nvoid main()\n{\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\n             v_rotation.y*P.x + v_rotation.x*P.y);\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\n    float distance = marker(P*point_size, v_size);\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\n}\n"));this.prog=new v.Program(e),this.prog.set_shaders("\nprecision mediump float;\nconst float SQRT_2 = 1.4142135623730951;\n//\nuniform float u_pixel_ratio;\nuniform vec2 u_canvas_size;\nuniform vec2 u_offset;\nuniform vec2 u_scale;\nuniform float u_antialias;\n//\nattribute float a_x;\nattribute float a_y;\nattribute float a_size;\nattribute float a_angle;  // in radians\nattribute float a_linewidth;\nattribute vec4  a_fg_color;\nattribute vec4  a_bg_color;\n//\nvarying float v_linewidth;\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying vec2  v_rotation;\n\nvoid main (void)\n{\n    v_size = a_size * u_pixel_ratio;\n    v_linewidth = a_linewidth * u_pixel_ratio;\n    v_fg_color = a_fg_color;\n    v_bg_color = a_bg_color;\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\n    // Calculate position - the -0.5 is to correct for canvas origin\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\n    pos += 0.5;  // make up for Bokeh's offset\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\n    gl_Position.y *= -1.0;\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\n}\n",n),this.vbo_x=new v.VertexBuffer(e),this.prog.set_attribute("a_x","float",this.vbo_x),this.vbo_y=new v.VertexBuffer(e),this.prog.set_attribute("a_y","float",this.vbo_y),this.vbo_s=new v.VertexBuffer(e),this.prog.set_attribute("a_size","float",this.vbo_s),this.vbo_a=new v.VertexBuffer(e),this.prog.set_attribute("a_angle","float",this.vbo_a),this.vbo_linewidth=new v.VertexBuffer(e),this.vbo_fg_color=new v.VertexBuffer(e),this.vbo_bg_color=new v.VertexBuffer(e),this.index_buffer=new v.IndexBuffer(e)}},{key:"draw",value:function(t,e,n){var a=e.glglyph,s=a.nvertices;if(a.data_changed){if(!isFinite(n.dx)||!isFinite(n.dy))return;a._baked_offset=[n.dx,n.dy],a._set_data(s),a.data_changed=!1}else this.glyph instanceof T.b&&null!=this.glyph._radius&&(null==this.last_trans||n.sx!=this.last_trans.sx||n.sy!=this.last_trans.sy)&&(this.last_trans=n,this.vbo_s.set_data(0,new Float32Array(Object(E.j)(this.glyph.sradius,(function(t){return 2*t})))));this.visuals_changed&&(this._set_visuals(s),this.visuals_changed=!1);var i=a._baked_offset;if(this.prog.set_uniform("u_pixel_ratio","float",[n.pixel_ratio]),this.prog.set_uniform("u_canvas_size","vec2",[n.width,n.height]),this.prog.set_uniform("u_offset","vec2",[n.dx-i[0],n.dy-i[1]]),this.prog.set_uniform("u_scale","vec2",[n.sx,n.sy]),this.prog.set_attribute("a_x","float",a.vbo_x),this.prog.set_attribute("a_y","float",a.vbo_y),this.prog.set_attribute("a_size","float",a.vbo_s),this.prog.set_attribute("a_angle","float",a.vbo_a),0!=t.length)if(t.length===s)this.prog.draw(this.gl.POINTS,[0,s]);else if(s<65535){var r=window.navigator.userAgent;r.indexOf("MSIE ")+r.indexOf("Trident/")+r.indexOf("Edge/")>0&&p.a.warn("WebGL warning: IE is known to produce 1px sprites whith selections."),this.index_buffer.set_size(2*t.length),this.index_buffer.set_data(0,new Uint16Array(t)),this.prog.draw(this.gl.POINTS,this.index_buffer)}else{for(var o=[],l=0,_=Math.ceil(s/64e3);l<_;l++)o.push([]);for(var h=0,c=t.length;h<c;h++){var f=t[h]%64e3;o[Math.floor(t[h]/64e3)].push(f)}for(var u=0,d=o.length;u<d;u++){var v=new Uint16Array(o[u]),g=64e3*u*4;0!==v.length&&(this.prog.set_attribute("a_x","float",a.vbo_x,0,g),this.prog.set_attribute("a_y","float",a.vbo_y,0,g),this.prog.set_attribute("a_size","float",a.vbo_s,0,g),this.prog.set_attribute("a_angle","float",a.vbo_a,0,g),this.vbo_linewidth.used&&this.prog.set_attribute("a_linewidth","float",this.vbo_linewidth,0,g),this.vbo_fg_color.used&&this.prog.set_attribute("a_fg_color","vec4",this.vbo_fg_color,0,4*g),this.vbo_bg_color.used&&this.prog.set_attribute("a_bg_color","vec4",this.vbo_bg_color,0,4*g),this.index_buffer.set_size(2*v.length),this.index_buffer.set_data(0,v),this.prog.draw(this.gl.POINTS,this.index_buffer))}}}},{key:"_set_data",value:function(t){var e=4*t;this.vbo_x.set_size(e),this.vbo_y.set_size(e),this.vbo_a.set_size(e),this.vbo_s.set_size(e);for(var n=new Float64Array(this.glyph._x),a=new Float64Array(this.glyph._y),s=0,i=t;s<i;s++)n[s]+=this._baked_offset[0],a[s]+=this._baked_offset[1];this.vbo_x.set_data(0,new Float32Array(n)),this.vbo_y.set_data(0,new Float32Array(a)),null!=this.glyph._angle&&this.vbo_a.set_data(0,new Float32Array(this.glyph._angle)),this.glyph instanceof T.b&&null!=this.glyph._radius?this.vbo_s.set_data(0,new Float32Array(Object(E.j)(this.glyph.sradius,(function(t){return 2*t})))):this.vbo_s.set_data(0,new Float32Array(this.glyph._size))}},{key:"_set_visuals",value:function(t){!function(t,e,n,a,s,i){if(s.doit)if(m(s,i))e.used=!1,t.set_attribute(n,"float",s[i].value());else{e.used=!0;var r=new Float32Array(s.get_array(i));e.set_size(4*a),e.set_data(0,r),t.set_attribute(n,"float",e)}else e.used=!1,t.set_attribute(n,"float",[0])}(this.prog,this.vbo_linewidth,"a_linewidth",t,this.glyph.visuals.line,"line_width"),x(this.prog,this.vbo_fg_color,"a_fg_color",t,this.glyph.visuals.line,"line"),x(this.prog,this.vbo_bg_color,"a_bg_color",t,this.glyph.visuals.fill,"fill"),this.prog.set_uniform("u_antialias","float",[.8])}}]),n}(y);function I(t){return function(e){s()(a,e);var n=S(a);function a(){return f()(this,a),n.apply(this,arguments)}return d()(a,[{key:"_marker_code",get:function(){return t}}]),a}(R)}R.__name__="MarkerGLGlyph";var j=I("\nfloat marker(vec2 P, float size)\n{\n    return length(P) - size/2.0;\n}\n"),G=I("\nfloat marker(vec2 P, float size)\n{\n    return max(abs(P.x), abs(P.y)) - size/2.0;\n}\n"),L=I("\nfloat marker(vec2 P, float size)\n{\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\n    return r1 / SQRT_2;\n}\n"),O=I("\nfloat marker(vec2 P, float size)\n{\n    P.y -= size * 0.3;\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\n    float r2 = P.y;\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\n}\n"),D=I("\nfloat marker(vec2 P, float size)\n{\n    P.y += size * 0.3;\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\n    float r2 = - P.y;\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\n}\n"),M=I("\nfloat marker(vec2 P, float size)\n{\n    vec2 q = abs(P);\n    return max(q.y * 0.57735 + q.x - 1.0 * size/2.0, q.y - 0.866 * size/2.0);\n}\n"),F=I('\nfloat marker(vec2 P, float size)\n{\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;   // 2.5 is a tweak\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of "width" for aa\n    return max(square, cross);\n}\n'),V=I("\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float circle = length(P) - size/2.0;\n    float c1 = max(circle, s1);\n    float c2 = max(circle, s2);\n    float c3 = max(circle, s3);\n    float c4 = max(circle, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),C=I("\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\n    float c1 = max(square, s1);\n    float c2 = max(square, s2);\n    float c3 = max(square, s3);\n    float c4 = max(square, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),B=I("\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\n    diamond /= SQRT_2;\n    float c1 = max(diamond, s1);\n    float c2 = max(diamond, s2);\n    float c3 = max(diamond, s3);\n    float c4 = max(diamond, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),N=I('\nfloat marker(vec2 P, float size)\n{\n    float circle = length(P) - size / 1.6;\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of "width" for aa\n    return max(circle, X);\n}\n'),U=I('\nfloat marker(vec2 P, float size)\n{\n    float x = P.x - P.y;\n    float y = P.x + P.y;\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float circle = length(P) - size/2.0;\n    float c1 = max(circle, s1);\n    float c2 = max(circle, s2);\n    float c3 = max(circle, s3);\n    float c4 = max(circle, s4);\n    // Union\n    float almost = min(min(min(c1, c2), c3), c4);\n    // In this case, the X is also outside of the main shape\n    float Xmask = length(P) - size / 1.6;  // a circle\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of "width" for aa\n    return min(max(X, Xmask), almost);\n}\n'),Q=I("\nfloat marker(vec2 P, float size)\n{\n    float x = P.x - P.y;\n    float y = P.x + P.y;\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\n    float c1 = max(square, s1);\n    float c2 = max(square, s2);\n    float c3 = max(square, s3);\n    float c4 = max(square, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),X=I('\nfloat marker(vec2 P, float size)\n{\n    // Masks\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\n    // Shapes\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of "width" for aa\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of "width" for aa\n    // Result is union of masked shapes\n    return min(max(X, diamond), max(cross, square));\n}\n')},189:function(t,e,n){(function(e){var a,s,i,r,o,l,_,h,c,f=n(20),u=function(t,e){return Array.isArray(t)&&Array.isArray(e)?t.concat(e):t+e},d=function(t,e){if(null==e);else{if(Array.isArray(e)){for(var n=0;n<e.length;n++)if(v(t,e[n]))return!0;return!1}if(e.constructor===Object){for(var a in e)if(t==a)return!0;return!1}if(e.constructor==String)return e.indexOf(t)>=0}var s=Error("Not a container: "+e);throw s.name="TypeError",s},v=function t(e,n){if(null==e||null==n);else{if(Array.isArray(e)&&Array.isArray(n)){for(var a=0,s=e.length==n.length;s&&a<e.length;)s=t(e[a],n[a]),a+=1;return s}if(e.constructor===Object&&n.constructor===Object){var i=Object.keys(e),r=Object.keys(n);i.sort(),r.sort();var o;for(a=0,s=t(i,r);s&&a<i.length;)s=t(e[o=i[a]],n[o]),a+=1;return s}}return e==n},g=function(t,n){if(void 0===t||"undefined"!=typeof window&&window===t||void 0!==e&&e===t)throw"Class constructor is called as a function.";for(var a in t)void 0!==Object[a]||"function"!=typeof t[a]||t[a].nobind||(t[a]=t[a].bind(t));t.__init__&&t.__init__.apply(t,n)},p=function(t,e){if(("number"==typeof t)+("number"==typeof e)===1){if(t.constructor===String)return A.call(t,e);if(e.constructor===String)return A.call(e,t);if(Array.isArray(e)){var n=t;t=e,e=n}if(Array.isArray(t)){for(var a=[],s=0;s<e;s++)a=a.concat(t);return a}}return t*e},y=function(t){return null===t||"object"!==f(t)?t:void 0!==t.length?!!t.length&&t:void 0!==t.byteLength?!!t.byteLength&&t:t.constructor!==Object||!!Object.getOwnPropertyNames(t).length&&t},m=function(t){if(!Array.isArray(this))return this.append.apply(this,arguments);this.push(t)},x=function(t,e){return this.constructor!==Object?this.get.apply(this,arguments):void 0!==this[t]?this[t]:void 0!==e?e:null},b=function(){return"function"==typeof this.keys?this.keys.apply(this,arguments):Object.keys(this)},w=function(t){if(this.constructor!==String)return this.lstrip.apply(this,arguments);t=void 0===t?" \t\r\n":t;for(var e=0;e<this.length;e++)if(t.indexOf(this[e])<0)return this.slice(e);return""},P=function(t){if(!Array.isArray(this))return this.remove.apply(this,arguments);for(var e=0;e<this.length;e++)if(v(this[e],t))return void this.splice(e,1);var n=Error(t);throw n.name="ValueError",n},A=function(t){if(this.repeat)return this.repeat(t);if(t<1)return"";for(var e="",n=this.valueOf();t>1;)1&t&&(e+=n),t>>=1,n+=n;return e+n},z=function(t){return this.constructor!==String?this.startswith.apply(this,arguments):0==this.indexOf(t)};c=window.console,h=function(t,e){var n,a,s,i,r,o,l;for(e=void 0===e?"periodic check":e,i=[];a=t.getError(),!(v(a,t.NO_ERROR)||y(i)&&v(a,i[i.length-1]));)m.call(i,a);if(i.length){for(r="","object"!==f(o=i)||Array.isArray(o)||(o=Object.keys(o)),l=0;l<o.length;l+=1)n=o[l],r=u(r,n);throw(s=new Error("RuntimeError:OpenGL got errors ("+e+"): "+r)).name="RuntimeError",s}return null},(s=function(){g(this,arguments)}).prototype._base_class=Object,s.prototype._class_name="GlooObject",s.prototype.__init__=function(t){if(this._gl=t,this.handle=null,this._create(),null===this.handle)throw"AssertionError: this.handle !== null";return null},s.prototype._create=function(){var t;throw(t=new Error("NotImplementedError:")).name="NotImplementedError",t},((r=function(){g(this,arguments)}).prototype=Object.create(s.prototype))._base_class=s.prototype,r.prototype._class_name="Program",r.prototype.UTYPEMAP={float:"uniform1fv",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1iv",ivec2:"uniform2iv",ivec3:"uniform3iv",ivec4:"uniform4iv",bool:"uniform1iv",bvec2:"uniform2iv",bvec3:"uniform3iv",bvec4:"uniform4iv",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv",sampler1D:"uniform1i",sampler2D:"uniform1i",sampler3D:"uniform1i"},r.prototype.ATYPEMAP={float:"vertexAttrib1f",vec2:"vertexAttrib2f",vec3:"vertexAttrib3f",vec4:"vertexAttrib4f"},r.prototype.ATYPEINFO={float:[1,5126],vec2:[2,5126],vec3:[3,5126],vec4:[4,5126]},r.prototype._create=function(){return this.handle=this._gl.createProgram(),this.locations={},this._unset_variables=[],this._validated=!1,this._samplers={},this._attributes={},this._known_invalid=[],null},r.prototype.delete=function(){return this._gl.deleteProgram(this.handle),null},r.prototype.activate=function(){return this._gl.useProgram(this.handle),null},r.prototype.deactivate=function(){return this._gl.useProgram(0),null},r.prototype.set_shaders=function(t,e){var n,a,s,i,r,o,l,_,h,c,f,d,v;for(o=this._gl,this._linked=!1,f=[[t,v=o.createShader(o.VERTEX_SHADER),"vertex"],[e,r=o.createShader(o.FRAGMENT_SHADER),"fragment"]],_=0;_<2;_+=1)if(n=(c=f[_])[0],l=c[1],d=c[2],o.shaderSource(l,n),o.compileShader(l),h=o.getShaderParameter(l,o.COMPILE_STATUS),!y(h))throw i=o.getShaderInfoLog(l),(s=new Error("RuntimeError:"+u("errors in "+d+" shader:\n",i))).name="RuntimeError",s;if(o.attachShader(this.handle,v),o.attachShader(this.handle,r),o.linkProgram(this.handle),!y(o.getProgramParameter(this.handle,o.LINK_STATUS)))throw(a=new Error("RuntimeError:Program link error:\n"+o.getProgramInfoLog(this.handle))).name="RuntimeError",a;return this._unset_variables=this._get_active_attributes_and_uniforms(),o.detachShader(this.handle,v),o.detachShader(this.handle,r),o.deleteShader(v),o.deleteShader(r),this._known_invalid=[],this._linked=!0,null},r.prototype._get_active_attributes_and_uniforms=function(){var t,e,n,a,s,i,r,o,l,_,h,c,d,v,g,p,x,b;for(o=this._gl,this.locations={},v=new window.RegExp("(\\w+)\\s*(\\[(\\d+)\\])\\s*"),s=o.getProgramParameter(this.handle,o.ACTIVE_UNIFORMS),e=o.getProgramParameter(this.handle,o.ACTIVE_ATTRIBUTES),b=[],p=[[t=[],e,o.getActiveAttrib,o.getAttribLocation],[b,s,o.getActiveUniform,o.getUniformLocation]],"object"!==f(p)||Array.isArray(p)||(p=Object.keys(p)),x=0;x<p.length;x+=1)for(n=(g=p[x])[0],a=g[1],i=g[2],r=g[3],l=0;l<a;l+=1){if(c=(d=(_=i.call(o,this.handle,l)).name).match(v),y(c))for(d=c[1],h=0;h<_.size;h+=1)m.call(n,[d+"["+h+"]",_.type]);else m.call(n,[d,_.type]);this.locations[d]=r.call(o,this.handle,d)}return u(function(){var e,n,a,s=[];for("object"!==f(n=t)||Array.isArray(n)||(n=Object.keys(n)),a=0;a<n.length;a++)e=n[a],s.push(e[0]);return s}.apply(this),function(){var t,e,n,a=[];for("object"!==f(e=b)||Array.isArray(e)||(e=Object.keys(e)),n=0;n<e.length;n++)t=e[n],a.push(t[0]);return a}.apply(this))},r.prototype.set_texture=function(t,e){var n,a,s;if(!y(this._linked))throw(n=new Error("RuntimeError:Cannot set uniform when program has no code")).name="RuntimeError",n;return a=x.call(this.locations,t,-1),y(a<0)?(d(t,this._known_invalid)||(m.call(this._known_invalid,t),c.log("Variable "+t+" is not an active texture")),null):(d(t,this._unset_variables)&&P.call(this._unset_variables,t),this.activate(),s=b.call(this._samplers).length,d(t,this._samplers)&&(s=this._samplers[t][this._samplers[t].length-1]),this._samplers[t]=[e._target,e.handle,s],this._gl.uniform1i(a,s),null)},r.prototype.set_uniform=function(t,e,n){var a,s,i,r,o,l,_;if(!y(this._linked))throw(i=new Error("RuntimeError:Cannot set uniform when program has no code")).name="RuntimeError",i;if(o=x.call(this.locations,t,-1),y(o<0))return d(t,this._known_invalid)||(m.call(this._known_invalid,t),c.log("Variable "+t+" is not an active uniform")),null;if(d(t,this._unset_variables)&&P.call(this._unset_variables,t),s=1,z.call(e,"mat")||(a=x.call({int:"float",bool:"float"},e,w.call(e,"ib")),s=Math.floor(n.length/this.ATYPEINFO[a][0])),y(s>1))for(l=0;l<s;l+=1)d(t+"["+l+"]",this._unset_variables)&&d(_=t+"["+l+"]",this._unset_variables)&&P.call(this._unset_variables,_);return r=this.UTYPEMAP[e],this.activate(),z.call(e,"mat")?this._gl[r](o,!1,n):this._gl[r](o,n),null},r.prototype.set_attribute=function(t,e,n,a,s){var i,r,o,l,h,f;if(a=void 0===a?0:a,s=void 0===s?0:s,!y(this._linked))throw(r=new Error("RuntimeError:Cannot set attribute when program has no code")).name="RuntimeError",r;return h=n instanceof _,l=x.call(this.locations,t,-1),y(l<0)?(d(t,this._known_invalid)||(m.call(this._known_invalid,t),y(h)&&y(s>0)||c.log("Variable "+t+" is not an active attribute")),null):(d(t,this._unset_variables)&&P.call(this._unset_variables,t),this.activate(),y(h)?(o="vertexAttribPointer",i=[(f=this.ATYPEINFO[e])[0],f[1],this._gl.FALSE,a,s],this._attributes[t]=[n.handle,l,o,i]):(o=this.ATYPEMAP[e],this._attributes[t]=[0,l,o,n]),null)},r.prototype._pre_draw=function(){var t,e,n,a,s,i,r,o,l,_,h,c;for(c in this.activate(),r=this._samplers)r.hasOwnProperty(c)&&(l=(i=c=r[c])[0],o=i[1],_=i[2],this._gl.activeTexture(u(this._gl.TEXTURE0,_)),this._gl.bindTexture(l,o));for(c in s=this._attributes)s.hasOwnProperty(c)&&(h=(a=c=s[c])[0],e=a[1],n=a[2],t=a[3],y(h)?(this._gl.bindBuffer(this._gl.ARRAY_BUFFER,h),this._gl.enableVertexAttribArray(e),this._gl[n].apply(this._gl,[].concat([e],t))):(this._gl.bindBuffer(this._gl.ARRAY_BUFFER,null),this._gl.disableVertexAttribArray(e),this._gl[n].apply(this._gl,[].concat([e],t))));return y(this._validated)||(this._validated=!0,this._validate()),null},r.prototype._validate=function(){var t;if(this._unset_variables.length&&c.log("Program has unset variables: "+this._unset_variables),this._gl.validateProgram(this.handle),!y(this._gl.getProgramParameter(this.handle,this._gl.VALIDATE_STATUS)))throw c.log(this._gl.getProgramInfoLog(this.handle)),(t=new Error("RuntimeError:Program validation error")).name="RuntimeError",t;return null},r.prototype.draw=function(t,e){var n,a,s,r,o;if(!y(this._linked))throw(a=new Error("RuntimeError:Cannot draw program if code has not been set")).name="RuntimeError",a;return h(this._gl,"before draw"),y(e instanceof i)?(this._pre_draw(),e.activate(),n=e._buffer_size/2,r=this._gl.UNSIGNED_SHORT,this._gl.drawElements(t,n,r,0),e.deactivate()):(s=(o=e)[0],n=o[1],y(n)&&(this._pre_draw(),this._gl.drawArrays(t,s,n))),h(this._gl,"after draw"),null},((a=function(){g(this,arguments)}).prototype=Object.create(s.prototype))._base_class=s.prototype,a.prototype._class_name="Buffer",a.prototype._target=null,a.prototype._usage=35048,a.prototype._create=function(){return this.handle=this._gl.createBuffer(),this._buffer_size=0,null},a.prototype.delete=function(){return this._gl.deleteBuffer(this.handle),null},a.prototype.activate=function(){return this._gl.bindBuffer(this._target,this.handle),null},a.prototype.deactivate=function(){return this._gl.bindBuffer(this._target,null),null},a.prototype.set_size=function(t){return v(t,this._buffer_size)||(this.activate(),this._gl.bufferData(this._target,t,this._usage),this._buffer_size=t),null},a.prototype.set_data=function(t,e){return this.activate(),this._gl.bufferSubData(this._target,t,e),null},(_=function(){g(this,arguments)}).prototype=Object.create(a.prototype),_.prototype._base_class=a.prototype,_.prototype._class_name="VertexBuffer",_.prototype._target=34962,(i=function(){g(this,arguments)}).prototype=Object.create(a.prototype),i.prototype._base_class=a.prototype,i.prototype._class_name="IndexBuffer",i.prototype._target=34963,((o=function(){g(this,arguments)}).prototype=Object.create(s.prototype))._base_class=s.prototype,o.prototype._class_name="Texture2D",o.prototype._target=3553,o.prototype._types={Int8Array:5120,Uint8Array:5121,Int16Array:5122,Uint16Array:5123,Int32Array:5124,Uint32Array:5125,Float32Array:5126},o.prototype._create=function(){return this.handle=this._gl.createTexture(),this._shape_format=null,null},o.prototype.delete=function(){return this._gl.deleteTexture(this.handle),null},o.prototype.activate=function(){return this._gl.bindTexture(this._target,this.handle),null},o.prototype.deactivate=function(){return this._gl.bindTexture(this._target,0),null},o.prototype._get_alignment=function(t){var e,n,a;for("object"!==f(n=[4,8,2,1])||Array.isArray(n)||(n=Object.keys(n)),a=0;a<n.length;a+=1)if(e=n[a],v(t%e,0))return e;return null},o.prototype.set_wrapping=function(t,e){return this.activate(),this._gl.texParameterf(this._target,this._gl.TEXTURE_WRAP_S,t),this._gl.texParameterf(this._target,this._gl.TEXTURE_WRAP_T,e),null},o.prototype.set_interpolation=function(t,e){return this.activate(),this._gl.texParameterf(this._target,this._gl.TEXTURE_MIN_FILTER,t),this._gl.texParameterf(this._target,this._gl.TEXTURE_MAG_FILTER,e),null},o.prototype.set_size=function(t,e){var n,a,s;return n=(a=t)[0],s=a[1],v([n,s,e],this._shape_format)||(this._shape_format=[n,s,e],this.activate(),this._gl.texImage2D(this._target,0,e,s,n,0,e,this._gl.UNSIGNED_BYTE,null)),this.u_shape=[n,s],null},o.prototype.set_data=function(t,e,n){var a,s,i,r,o,l,_,h,c,f;if(v(e.length,2)&&(e=[e[0],e[1],1]),this.activate(),i=this._shape_format[2],o=(l=e)[0],h=l[1],l[2],f=(_=t)[0],c=_[1],null===(r=x.call(this._types,n.constructor.name,null)))throw(s=new Error("ValueError:Type "+n.constructor.name+" not allowed for texture")).name="ValueError",s;return a=this._get_alignment(p(e[e.length-2],e[e.length-1])),v(a,4)||this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,a),this._gl.texSubImage2D(this._target,0,c,f,h,o,i,r,n),v(a,4)||this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,4),null},((l=function(){g(this,arguments)}).prototype=Object.create(o.prototype))._base_class=o.prototype,l.prototype._class_name="Texture3DLike",l.prototype.GLSL_SAMPLE_NEAREST="\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\n            shape.xyz = shape.zyx;  // silly row-major convention\n            float nrows = tiles.y, ncols = tiles.x;\n            // Don't let adjacent frames be interpolated into this one\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\n\n            float zindex = floor(texcoord.z * shape.z);\n\n            // Do a lookup in the 2D texture\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\n\n            return texture2D(tex, vec2(u,v));\n        }\n    ",l.prototype.GLSL_SAMPLE_LINEAR="\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\n            shape.xyz = shape.zyx;  // silly row-major convention\n            float nrows = tiles.y, ncols = tiles.x;\n            // Don't let adjacent frames be interpolated into this one\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\n\n            float z = texcoord.z * shape.z;\n            float zindex1 = floor(z);\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\n\n            float zindex2 = zindex1 + 1.0;\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\n\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\n\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\n        }\n    ",l.prototype._get_tile_info=function(t){var e,n,a,s;if(n=this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),s=Math.floor(n/t[1]),s=Math.min(s,t[0]),a=window.Math.ceil(t[0]/s),y(p(a,t[2])>n))throw(e=new Error("RuntimeError:Cannot fit 3D data with shape "+t+" onto simulated 2D texture.")).name="RuntimeError",e;return[s,a]},l.prototype.set_size=function(t,e){var n,a,s,i;return a=(i=this._get_tile_info(t))[0],n=i[1],s=[p(t[1],a),p(t[2],n)],l.prototype._base_class.set_size.call(this,s,e),this.u_shape=[t[0],t[1],t[2]],this.u_tiles=[n,a],null},l.prototype.set_data=function(t,e,n){var a,s,i,r,o,_,h,c,u,d,g,m;if(v(e.length,3)&&(e=[e[0],e[1],e[2],1]),!function(t){for(var e=0;e<t.length;e++)if(!y(t[e]))return!1;return!0}(function(){var e,n,a,s=[];for("object"!==f(n=t)||Array.isArray(n)||(n=Object.keys(n)),a=0;a<n.length;a++)e=n[a],s.push(v(e,0));return s}.apply(this)))throw(i=new Error("ValueError:Texture3DLike does not support nonzero offset (for now)")).name="ValueError",i;if(o=(c=this._get_tile_info(e))[0],r=c[1],h=[p(e[1],o),p(e[2],r),e[3]],v(r,1))l.prototype._base_class.set_data.call(this,[0,0],h,n);else for(m=new(0,n.constructor)(p(p(h[0],h[1]),h[2])),l.prototype._base_class.set_data.call(this,[0,0],h,m),g=0;g<e[0];g+=1)_=(u=[Math.floor(g/r),g%r])[0],a=u[1],s=Math.floor(n.length/e[0]),d=n.slice(p(g,s),p(g+1,s)),l.prototype._base_class.set_data.call(this,[p(_,e[1]),p(a,e[2])],e.slice(1),d);return null},t.exports={Buffer:a,GlooObject:s,IndexBuffer:i,Program:r,Texture2D:o,Texture3DLike:l,VertexBuffer:_,check_error:h,console:c}}).call(this,n(104))}}]);